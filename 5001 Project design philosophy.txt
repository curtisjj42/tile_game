Jason Curtis
CS 5001
Fall 2022
Final Project design

My project mostly follows the specs provided in the assignment as well as the videos. I spent some time working between pure procedural code and pure OO code, and ended up striking a balance point at primarily procedural with plenty of turtle usage and 3 self designed classes. I initially planned to fully design a tile class, but changed partway through the design due to difficulties adding click functionality to these tiles. I later solved this problem, but was far enough along in my code that I stuck with an overall procedural design focused on generating and tracking individual turtle objects for the tiles.

Once I solved all the problems with object initialization (detailed below), I built my game on a system of two 2d arrays. One holds the tiles in their current board configuration, while the other holds the winning configuration (the victory state). The array is built based on puzzle data, and it is a nested list that holds all rows in the game board, and then each row holds all the tiles in that row. By procedurally updating the current game state any time I move a tile, I can compare these arrays at specific checkpoints to determine if and when the player has won.

My design hinges on using nested functions to maintain accessible scopes for my various arrays used to keep track of my turtle objects. I started by writing a class for my quit, load, and reset buttons, but ran into significant trouble with the turtle.onclick() function which forced me to change my approach. Since the .onclick() function returns x,y coordinates, I knew how to use it to call a fxn I could define with x,y parameters (regardless of if I was using that data). But when I finished making my load fxn, I realized I needed it to interact with my reset fxn. Therefore, I needed to host the data storage arrays in my decision tree fxn. But, if I held the data there, how could I pass it to the load fxn with .onlick()? To solve this problem, I nested these fxns within my decision tree, which sits one level below my main(). This way, I could initialize the game, board objects, and buttons through my main, and then have my decision tree fxn decide where to pass individual pieces of data based on my inputs. 

Once I solved the problem of .onclick() here, I understood how to use it to create my tiles. I had already written the code to initialize my tiles as turtle objects with images and place them throughout the board, so I wrote a small nested fxn to give them clickability. Now, when clicking a tile, I could have it call a fxn chain to find the blank tile, return the blank tile's position in the current game state array, determine if it was either 1 row XOR one column away from the clicked tile, and if so exchange their game board and array positions. Thus their visual position was always tracked in the code. Finally, I designed my victory state checkpoint to trigger when the player moves the blank tile into the bottom right corner. This way, the game only needs to check the victory condition periodically, rather than every move. 